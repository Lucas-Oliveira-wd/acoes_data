cres_rec5 = round(as.numeric(cres_rec5), 2)
divY_t = round(as.numeric(divY_t), 2)
lynch = round((divY_t+(cres_rec5/5))/pl, 2)
lynch3 = round((divY_t/3+(cres_rec5/15))/pl3, 2)
div_lucm = round(divb/(as.numeric(Lucl3)/3), 2)
crit = data.frame(lp, lp3, vp, roe, roe3, roic, cxa_p, ativc_p, ativ_p,
div_cxa, marg_ebit, marg_ebit3 ,marg_liq, marg_liq3,
cres_rec5 ,divY_t ,lynch, lynch3, div_lucm,
row.names = codigo)
#############       filtrando o db        ###################################
#removendo valores infinitos
rmv_inf_values_row = function(df){
for (r in 1:nrow(df)){
if (is.na(match(Inf, df[r,])) || is.na(match(-1*Inf, df[r,]))){
} else {
print(paste('removendo ', row.names(df)[r], ', pois tem valor Inf'))
df = df[-r,]
}
}
non_numeric_cols <- sapply(df, function(x) any(is.na(as.numeric(x))))
print(names(df)[non_numeric_cols])
return(df)
}
crit = rmv_inf_values_row(crit)
###############     chatgpt start      ###############################
rmv_na_val <- function(df) {
incomplete_rows <- !complete.cases(df)
if (any(incomplete_rows)) {
#      print(paste("Removendo ", row.names(df)[incomplete_rows],
#                  ", pois têm valores NA"))
df <- df[complete.cases(df), ]
}
return(df)
}
crit <- rmv_na_val(crit)
###############     chatgpt  end     ###############################
colnames(crit) = c("L/P", 'L/P (tri)', "VPA/P", "ROE" , 'ROE (tri)', "ROIC",
"(Caixa/Ação)/Preço", "(Ativos Circulantes/Ação)/Preço",
"(Ativos/Ação)/Preço", "Dív Bruta/Caixa", "Marg. EBIT",
'Marg. EBIT (tri)', "Marg. Líquida", 'Marg. Líquida (tri)',
"Cresc. Rec. (5 Anos)", "Dividendyield", "Lynch",
'Lynch (tri)',  "Dív. Bruta/Lucro Mensal")
#gridExtra::grid.table(crit %>% slice(1:20))
crit_tri[[per]] = crit
print(paste('DF do periodo: ', ult_bal_dates[per], ' criado'))
}
#criando os valores dos critérios
for (per in 1:length(ult_bal_dates)){
print(paste('Criando o DF para o periodo: ', ult_bal_dates[per]))
#criando as variaveis do db diário
ult_cot = cod = cotAtual = divY = c()
# loop na coluna 'ultCot' do dbday
for (i in 1:nrow(df_day)){
# verificando se o codigo da ação já pertence a coluna do periodo df cod
if (df_day[i,"cod"] %in% cod){
# obtendo o número da posição desse código na varável cod
j = match(df_day[i,"cod"], cod)
# verificando se o valor da ultima cotação da iteração atual é maior que
#o valor pertencente à variável e menor ou igual a do período
if (as.Date(df_day[i,"ultCot"]) > as.Date(df_day[j,"ultCot"]) &&
as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])){
#se for maior: retirando o valor de cada variável correspondente à
#posição do valor pertencente
ult_cot = ult_cot[-j]; cod = cod[-j]; cotAtual = cotAtual[-j];
divY = divY[-j]
#colocando os valores que teve a maior ultCot (preço atualizado)
#ult_cot[per] = df_day[i,"ultCot"]    ### codigo travado
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
} else if (as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])) {
#se não pertence e é menor que o período:
#apenas colocando o valor da iteração atual
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
}
# criando o data.frame filtrado
df_day_fil = data.frame(cod, cotAtual, divY, ult_cot)
#passando o df para a lista
trimestres[[per]] = df_day_fil
#Criando as variáveis do db trimestral
ult_bal = codigo = roic = cres_rec5 = n_ac = divb = disp = ativc = c();
ativ = patl = recl12 = ebit12 = Lucl12 = recl3 = ebit3 = Lucl3 = c()
#Variáveis para unirem ao db trimestral
ult_cot_t = cotAtual_t = divY_t = c()
#loop através da coluna "ultBal" do db trimestral
for (i in 1:length(df_tri[,"ultBal"])){
#escolhendo o trimestre a ser trabalhado
if (df_tri[i,"ultBal"] == ult_bal_dates[per]){
#Verificando a linha do db trimestral à qual o código pertence
j = match(df_tri[i,"codigo"], cod)
#Colocanda cada valor das variáveis do dbday em cada posição
#correspondente no dbtri, além dos valores das variáveis do próprio
#dbtri
ult_cot_t = c(ult_cot_t, ult_cot[j])
cotAtual_t = c(cotAtual_t, cotAtual[j])
ult_bal =  c(ult_bal, df_tri[i,"ultBal"])
codigo = c(codigo, df_tri[i,"codigo"])
roic = c(roic, df_tri[i,"roic"])
cres_rec5 = c(cres_rec5, df_tri[i,"cresRec5a"])
divY_t = c(divY_t, divY[j])
n_ac = c(n_ac, df_tri[i,"nAcoes"])
divb = c(divb, df_tri[i,"divBruta"])
disp = c(disp, df_tri[i,"disponib"])
ativc = c(ativc, df_tri[i,"ativCirc"])
ativ = c(ativ, df_tri[i,"ativos"])
patl = c(patl, df_tri[i,"patLiq"])
recl12 = c(recl12, df_tri[i,"recLiq12m"])
ebit12 = c(ebit12, df_tri[i,"ebit12m"])
Lucl12 = c(Lucl12, df_tri[i,"LucLiq12m"])
recl3 = c(recl3, df_tri[i,"recLiq3m"])
ebit3 = c(ebit3, df_tri[i, "ebit3m"])
Lucl3 = c(Lucl3, df_tri[i, "LucLiq3m"])
}
}
#gridExtra::grid.table(df_tri_3t22 %>% slice(1:20))
# criando os índices
pl = round(cotAtual_t/(Lucl12/n_ac), 2)
pl3 = round(cotAtual_t/(as.numeric(Lucl3)/n_ac), 2)
lp = round((Lucl12/n_ac)/cotAtual_t, 2)
lp3 = round((as.numeric(Lucl3)/n_ac)/cotAtual_t, 2)
vp = round((patl/n_ac)/cotAtual_t, 2)
roe = round((Lucl12/patl)*100, 2)
roe3 = round((as.numeric(Lucl3)/patl)*100, 2)
roic = round(as.numeric(roic), 2)
cxa_p = round((disp/n_ac)/cotAtual_t, 2)
ativc_p = round((ativc/n_ac)/cotAtual_t, 2)
ativ_p = round((ativ/n_ac)/cotAtual_t, 2)
div_cxa = round(divb/disp, 2)
marg_ebit = round((ebit12/recl12)*100, 2)
marg_ebit3 = round((as.numeric(ebit3)/recl3)*100, 2)
marg_liq = round((Lucl12/recl12)*100, 2)
marg_liq3 = round((as.numeric(Lucl3)/recl3)*100, 2)
cres_rec5 = round(as.numeric(cres_rec5), 2)
divY_t = round(as.numeric(divY_t), 2)
lynch = round((divY_t+(cres_rec5/5))/pl, 2)
lynch3 = round((divY_t/3+(cres_rec5/15))/pl3, 2)
div_lucm = round(divb/(as.numeric(Lucl3)/3), 2)
crit = data.frame(lp, lp3, vp, roe, roe3, roic, cxa_p, ativc_p, ativ_p,
div_cxa, marg_ebit, marg_ebit3 ,marg_liq, marg_liq3,
cres_rec5 ,divY_t ,lynch, lynch3, div_lucm,
row.names = codigo)
#############       filtrando o db        ###################################
#removendo valores infinitos
rmv_inf_values_row = function(df){
for (r in 1:nrow(df)){
if (is.na(match(Inf, df[r,])) || is.na(match(-Inf, df[r,]))){
} else {
print(paste('removendo ', row.names(df)[r], ', pois tem valor Inf'))
df = df[-r,]
}
}
return(df)
}
crit = rmv_inf_values_row(crit)
###############     chatgpt start      ###############################
rmv_na_val <- function(df) {
incomplete_rows <- !complete.cases(df)
if (any(incomplete_rows)) {
#      print(paste("Removendo ", row.names(df)[incomplete_rows],
#                  ", pois têm valores NA"))
df <- df[complete.cases(df), ]
}
return(df)
}
crit <- rmv_na_val(crit)
###############     chatgpt  end     ###############################
colnames(crit) = c("L/P", 'L/P (tri)', "VPA/P", "ROE" , 'ROE (tri)', "ROIC",
"(Caixa/Ação)/Preço", "(Ativos Circulantes/Ação)/Preço",
"(Ativos/Ação)/Preço", "Dív Bruta/Caixa", "Marg. EBIT",
'Marg. EBIT (tri)', "Marg. Líquida", 'Marg. Líquida (tri)',
"Cresc. Rec. (5 Anos)", "Dividendyield", "Lynch",
'Lynch (tri)',  "Dív. Bruta/Lucro Mensal")
#gridExtra::grid.table(crit %>% slice(1:20))
crit_tri[[per]] = crit
print(paste('DF do periodo: ', ult_bal_dates[per], ' criado'))
}
#criando os valores dos critérios
for (per in 1:length(ult_bal_dates)){
print(paste('Criando o DF para o periodo: ', ult_bal_dates[per]))
#criando as variaveis do db diário
ult_cot = cod = cotAtual = divY = c()
# loop na coluna 'ultCot' do dbday
for (i in 1:nrow(df_day)){
# verificando se o codigo da ação já pertence a coluna do periodo df cod
if (df_day[i,"cod"] %in% cod){
# obtendo o número da posição desse código na varável cod
j = match(df_day[i,"cod"], cod)
# verificando se o valor da ultima cotação da iteração atual é maior que
#o valor pertencente à variável e menor ou igual a do período
if (as.Date(df_day[i,"ultCot"]) > as.Date(df_day[j,"ultCot"]) &&
as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])){
#se for maior: retirando o valor de cada variável correspondente à
#posição do valor pertencente
ult_cot = ult_cot[-j]; cod = cod[-j]; cotAtual = cotAtual[-j];
divY = divY[-j]
#colocando os valores que teve a maior ultCot (preço atualizado)
#ult_cot[per] = df_day[i,"ultCot"]    ### codigo travado
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
} else if (as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])) {
#se não pertence e é menor que o período:
#apenas colocando o valor da iteração atual
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
}
# criando o data.frame filtrado
df_day_fil = data.frame(cod, cotAtual, divY, ult_cot)
#passando o df para a lista
trimestres[[per]] = df_day_fil
#Criando as variáveis do db trimestral
ult_bal = codigo = roic = cres_rec5 = n_ac = divb = disp = ativc = c();
ativ = patl = recl12 = ebit12 = Lucl12 = recl3 = ebit3 = Lucl3 = c()
#Variáveis para unirem ao db trimestral
ult_cot_t = cotAtual_t = divY_t = c()
#loop através da coluna "ultBal" do db trimestral
for (i in 1:length(df_tri[,"ultBal"])){
#escolhendo o trimestre a ser trabalhado
if (df_tri[i,"ultBal"] == ult_bal_dates[per]){
#Verificando a linha do db trimestral à qual o código pertence
j = match(df_tri[i,"codigo"], cod)
#Colocanda cada valor das variáveis do dbday em cada posição
#correspondente no dbtri, além dos valores das variáveis do próprio
#dbtri
ult_cot_t = c(ult_cot_t, ult_cot[j])
cotAtual_t = c(cotAtual_t, cotAtual[j])
ult_bal =  c(ult_bal, df_tri[i,"ultBal"])
codigo = c(codigo, df_tri[i,"codigo"])
roic = c(roic, df_tri[i,"roic"])
cres_rec5 = c(cres_rec5, df_tri[i,"cresRec5a"])
divY_t = c(divY_t, divY[j])
n_ac = c(n_ac, df_tri[i,"nAcoes"])
divb = c(divb, df_tri[i,"divBruta"])
disp = c(disp, df_tri[i,"disponib"])
ativc = c(ativc, df_tri[i,"ativCirc"])
ativ = c(ativ, df_tri[i,"ativos"])
patl = c(patl, df_tri[i,"patLiq"])
recl12 = c(recl12, df_tri[i,"recLiq12m"])
ebit12 = c(ebit12, df_tri[i,"ebit12m"])
Lucl12 = c(Lucl12, df_tri[i,"LucLiq12m"])
recl3 = c(recl3, df_tri[i,"recLiq3m"])
ebit3 = c(ebit3, df_tri[i, "ebit3m"])
Lucl3 = c(Lucl3, df_tri[i, "LucLiq3m"])
}
}
#gridExtra::grid.table(df_tri_3t22 %>% slice(1:20))
# criando os índices
pl = round(cotAtual_t/(Lucl12/n_ac), 2)
pl3 = round(cotAtual_t/(as.numeric(Lucl3)/n_ac), 2)
lp = round((Lucl12/n_ac)/cotAtual_t, 2)
lp3 = round((as.numeric(Lucl3)/n_ac)/cotAtual_t, 2)
vp = round((patl/n_ac)/cotAtual_t, 2)
roe = round((Lucl12/patl)*100, 2)
roe3 = round((as.numeric(Lucl3)/patl)*100, 2)
roic = round(as.numeric(roic), 2)
cxa_p = round((disp/n_ac)/cotAtual_t, 2)
ativc_p = round((ativc/n_ac)/cotAtual_t, 2)
ativ_p = round((ativ/n_ac)/cotAtual_t, 2)
div_cxa = round(divb/disp, 2)
marg_ebit = round((ebit12/recl12)*100, 2)
marg_ebit3 = round((as.numeric(ebit3)/recl3)*100, 2)
marg_liq = round((Lucl12/recl12)*100, 2)
marg_liq3 = round((as.numeric(Lucl3)/recl3)*100, 2)
cres_rec5 = round(as.numeric(cres_rec5), 2)
divY_t = round(as.numeric(divY_t), 2)
lynch = round((divY_t+(cres_rec5/5))/pl, 2)
lynch3 = round((divY_t/3+(cres_rec5/15))/pl3, 2)
div_lucm = round(divb/(as.numeric(Lucl3)/3), 2)
crit = data.frame(lp, lp3, vp, roe, roe3, roic, cxa_p, ativc_p, ativ_p,
div_cxa, marg_ebit, marg_ebit3 ,marg_liq, marg_liq3,
cres_rec5 ,divY_t ,lynch, lynch3, div_lucm,
row.names = codigo)
#############       filtrando o db        ###################################
#removendo valores infinitos
#  rmv_inf_values_row = function(df){
#    for (r in 1:nrow(df)){
#      if (is.na(match(Inf, df[r,])) || is.na(match(-Inf, df[r,]))){
#
#      } else {
#        print(paste('removendo ', row.names(df)[r], ', pois tem valor Inf'))
#        df = df[-r,]
#      }
#
#    }
#    return(df)
#  }
###############     chatgpt start      ###############################
rmv_inf_values_row <- function(df) {
rows_with_inf <- apply(df, 1, function(row) any(is.infinite(row)))
df <- df[!rows_with_inf, ]
return(df)
}
###############     chatgpt  end     ###############################
crit = rmv_inf_values_row(crit)
###############     chatgpt start      ###############################
rmv_na_val <- function(df) {
incomplete_rows <- !complete.cases(df)
if (any(incomplete_rows)) {
#      print(paste("Removendo ", row.names(df)[incomplete_rows],
#                  ", pois têm valores NA"))
df <- df[complete.cases(df), ]
}
return(df)
}
crit <- rmv_na_val(crit)
###############     chatgpt  end     ###############################
colnames(crit) = c("L/P", 'L/P (tri)', "VPA/P", "ROE" , 'ROE (tri)', "ROIC",
"(Caixa/Ação)/Preço", "(Ativos Circulantes/Ação)/Preço",
"(Ativos/Ação)/Preço", "Dív Bruta/Caixa", "Marg. EBIT",
'Marg. EBIT (tri)', "Marg. Líquida", 'Marg. Líquida (tri)',
"Cresc. Rec. (5 Anos)", "Dividendyield", "Lynch",
'Lynch (tri)',  "Dív. Bruta/Lucro Mensal")
#gridExtra::grid.table(crit %>% slice(1:20))
crit_tri[[per]] = crit
print(paste('DF do periodo: ', ult_bal_dates[per], ' criado'))
}
view(crit_tri[[5]])
library(tidyverse)
library(gridExtra)
library(ggplot2)
library(readxl)
df_tri = read.csv("data/acoesb3.csv")
df_day = read.csv("data/acoesb3cot.csv")
#coletando as datas dos últimos balanços
ult_bal_dates = c()
for (i in df_tri[,"ultBal"]){
if (i %in% ult_bal_dates){}
else{
ult_bal_dates = c(ult_bal_dates, i)
}
}
#retirando os valores das empresas que tem os trimestres vigentes diferentes
#de 31/03, 30/06, 30/09 e 31/12
for (t in ult_bal_dates) {
if (endsWith(t, '03-31')){} else if(endsWith(t, '06-30')){}
else if(endsWith(t, '09-30')){} else if(endsWith(t, '12-31')){}else {
ult_bal_dates = ult_bal_dates[-match(t, ult_bal_dates)]
}
}
#gridExtra::grid.table(df_day %>% slice(1:20)) # para plotar o db
################################################################################
############      CRIANDO OS DFs DIÁRIOS     ###################################
################################################################################
#separando os df por períodos
#lista para conter os períodos
trimestres = list()
#lista para conter os critérios por períodos
crit_tri = list()
#criando os valores dos critérios
for (per in 1:length(ult_bal_dates)){
print(paste('Criando o DF para o periodo: ', ult_bal_dates[per]))
#criando as variaveis do db diário
ult_cot = cod = cotAtual = divY = c()
# loop na coluna 'ultCot' do dbday
for (i in 1:nrow(df_day)){
# verificando se o codigo da ação já pertence a coluna do periodo df cod
if (df_day[i,"cod"] %in% cod){
# obtendo o número da posição desse código na varável cod
j = match(df_day[i,"cod"], cod)
# verificando se o valor da ultima cotação da iteração atual é maior que
#o valor pertencente à variável e menor ou igual a do período
if (as.Date(df_day[i,"ultCot"]) > as.Date(df_day[j,"ultCot"]) &&
as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])){
#se for maior: retirando o valor de cada variável correspondente à
#posição do valor pertencente
ult_cot = ult_cot[-j]; cod = cod[-j]; cotAtual = cotAtual[-j];
divY = divY[-j]
#colocando os valores que teve a maior ultCot (preço atualizado)
#ult_cot[per] = df_day[i,"ultCot"]    ### codigo travado
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
} else if (as.Date(df_day[i,'ultCot']) <= as.Date(ult_bal_dates[per])) {
#se não pertence e é menor que o período:
#apenas colocando o valor da iteração atual
ult_cot = c(ult_cot, df_day[i,"ultCot"])
cod = c(cod, df_day[i,"cod"])
cotAtual = c(cotAtual, df_day[i,"cotAtual"])
divY = c(divY, df_day[i, "divYield"])
}
}
# criando o data.frame filtrado
df_day_fil = data.frame(cod, cotAtual, divY, ult_cot)
#passando o df para a lista
trimestres[[per]] = df_day_fil
#Criando as variáveis do db trimestral
ult_bal = codigo = roic = cres_rec5 = n_ac = divb = disp = ativc = c();
ativ = patl = recl12 = ebit12 = Lucl12 = recl3 = ebit3 = Lucl3 = c()
#Variáveis para unirem ao db trimestral
ult_cot_t = cotAtual_t = divY_t = c()
#loop através da coluna "ultBal" do db trimestral
for (i in 1:length(df_tri[,"ultBal"])){
#escolhendo o trimestre a ser trabalhado
if (df_tri[i,"ultBal"] == ult_bal_dates[per]){
#Verificando a linha do db trimestral à qual o código pertence
j = match(df_tri[i,"codigo"], cod)
#Colocanda cada valor das variáveis do dbday em cada posição
#correspondente no dbtri, além dos valores das variáveis do próprio
#dbtri
ult_cot_t = c(ult_cot_t, ult_cot[j])
cotAtual_t = c(cotAtual_t, cotAtual[j])
ult_bal =  c(ult_bal, df_tri[i,"ultBal"])
codigo = c(codigo, df_tri[i,"codigo"])
roic = c(roic, df_tri[i,"roic"])
cres_rec5 = c(cres_rec5, df_tri[i,"cresRec5a"])
divY_t = c(divY_t, divY[j])
n_ac = c(n_ac, df_tri[i,"nAcoes"])
divb = c(divb, df_tri[i,"divBruta"])
disp = c(disp, df_tri[i,"disponib"])
ativc = c(ativc, df_tri[i,"ativCirc"])
ativ = c(ativ, df_tri[i,"ativos"])
patl = c(patl, df_tri[i,"patLiq"])
recl12 = c(recl12, df_tri[i,"recLiq12m"])
ebit12 = c(ebit12, df_tri[i,"ebit12m"])
Lucl12 = c(Lucl12, df_tri[i,"LucLiq12m"])
recl3 = c(recl3, df_tri[i,"recLiq3m"])
ebit3 = c(ebit3, df_tri[i, "ebit3m"])
Lucl3 = c(Lucl3, df_tri[i, "LucLiq3m"])
}
}
#gridExtra::grid.table(df_tri_3t22 %>% slice(1:20))
# criando os índices
pl = round(cotAtual_t/(Lucl12/n_ac), 2)
pl3 = round(cotAtual_t/(as.numeric(Lucl3)/n_ac), 2)
lp = round((Lucl12/n_ac)/cotAtual_t, 2)
lp3 = round((as.numeric(Lucl3)/n_ac)/cotAtual_t, 2)
vp = round((patl/n_ac)/cotAtual_t, 2)
roe = round((Lucl12/patl)*100, 2)
roe3 = round((as.numeric(Lucl3)/patl)*100, 2)
roic = round(as.numeric(roic), 2)
cxa_p = round((disp/n_ac)/cotAtual_t, 2)
ativc_p = round((ativc/n_ac)/cotAtual_t, 2)
ativ_p = round((ativ/n_ac)/cotAtual_t, 2)
div_cxa = round(divb/disp, 2)
marg_ebit = round((ebit12/recl12)*100, 2)
marg_ebit3 = round((as.numeric(ebit3)/recl3)*100, 2)
marg_liq = round((Lucl12/recl12)*100, 2)
marg_liq3 = round((as.numeric(Lucl3)/recl3)*100, 2)
cres_rec5 = round(as.numeric(cres_rec5), 2)
divY_t = round(as.numeric(divY_t), 2)
lynch = round((divY_t+(cres_rec5/5))/pl, 2)
lynch3 = round((divY_t/3+(cres_rec5/15))/pl3, 2)
div_lucm = round(divb/(as.numeric(Lucl3)/3), 2)
crit = data.frame(lp, lp3, vp, roe, roe3, roic, cxa_p, ativc_p, ativ_p,
div_cxa, marg_ebit, marg_ebit3 ,marg_liq, marg_liq3,
cres_rec5 ,divY_t ,lynch, lynch3, div_lucm,
row.names = codigo)
#############       filtrando o db        ###################################
#removendo valores infinitos
#  rmv_inf_values_row = function(df){
#    for (r in 1:nrow(df)){
#      if (is.na(match(Inf, df[r,])) || is.na(match(-Inf, df[r,]))){
#
#      } else {
#        print(paste('removendo ', row.names(df)[r], ', pois tem valor Inf'))
#        df = df[-r,]
#      }
#
#    }
#    return(df)
#  }
###############     chatgpt start      ###############################
rmv_inf_values_row <- function(df) {
rows_with_inf <- apply(df, 1, function(row) any(is.infinite(row)))
df <- df[!rows_with_inf, ]
return(df)
}
###############     chatgpt  end     ###############################
crit = rmv_inf_values_row(crit)
###############     chatgpt start      ###############################
rmv_na_val <- function(df) {
incomplete_rows <- !complete.cases(df)
if (any(incomplete_rows)) {
#      print(paste("Removendo ", row.names(df)[incomplete_rows],
#                  ", pois têm valores NA"))
df <- df[complete.cases(df), ]
}
return(df)
}
crit <- rmv_na_val(crit)
###############     chatgpt  end     ###############################
colnames(crit) = c("L/P", 'L/P (tri)', "VPA/P", "ROE" , 'ROE (tri)', "ROIC",
"(Caixa/Ação)/Preço", "(Ativos Circulantes/Ação)/Preço",
"(Ativos/Ação)/Preço", "Dív Bruta/Caixa", "Marg. EBIT",
'Marg. EBIT (tri)', "Marg. Líquida", 'Marg. Líquida (tri)',
"Cresc. Rec. (5 Anos)", "Dividendyield", "Lynch",
'Lynch (tri)',  "Dív. Bruta/Lucro Mensal")
#gridExtra::grid.table(crit %>% slice(1:20))
crit_tri[[per]] = crit
print(paste('DF do periodo: ', ult_bal_dates[per], ' criado'))
}
#################         coeficiente de correlação         ####################]
library(openxlsx)
cor_tab = data.frame(cor(crit_tri[[5]]))
write.xlsx(cor_tab,
file = 'C:/files/projects/programacao/python/acoes_data/correlacao.xlsx')
view(crit_tri[[5]])
##      diagrama de dispersão
plot(crit_tri[[5]]$`Marg. EBIT`, crit_tri[[5]]$`Marg. EBIT (tri)`)
