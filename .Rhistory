} else {
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
desv_times*sd(s_col)), arredond)
}
if (s > max(input)){
s = max(input)
} else if (s < min(input)){
s = min(input)
}
} else {
s = round(sample(sort(input)[match(limit_min,sort(input)):length(input)], 1),
arredond)
}
#################     r     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(r_col) == 0){
if (mean(r_col) == 0){
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
abs(mean(r_col))), arredond)
}
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
desv_times*sd(r_col)), arredond)
}
if (r > s){
r = s
} else if (r < min(input)){
r = min(input)
}
} else {
r = ifelse(s<=limit_min,s,round(sample(sort(input)[1:match(s,sort(input))],
1),arredond))
}
#################     q     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(q_col) == 0){
if (mean(q_col) == 0){
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
abs(mean(q_col))), arredond)
}
} else {
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
desv_times*sd(q_col)), arredond)
}
if (q > r){
q = r
} else if (q < min(input)){
q = min(input)
}
} else {
q = round(sample(sort(input)[1:match(r,sort(input))], 1), arredond)
}
#################     p     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(p_col) == 0){
if (mean(p_col) == 0){
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
sd = abs(mean(p_col))), arredond)
}
} else {
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
desv_times*sd(p_col)), arredond)
}
if (p > q){
p = q
} else if (p < min(input)){
p = min(input)
}
} else {
p = round(sample(sort(input)[1:match(q, sort(input))], 1), arredond)
}
}
print(paste('p: ', p))
print(paste('q: ', q))
print(paste('r: ', r))
print(paste('s: ', s))
#gerando a função que mostra o grau de pertencimento ao conjunto de
#boas ações
boa = TrapezoidalFuzzyNumber(p, q, r, s)
output = c()
for (ent in input) {
# Cálculo do grau de pertinência
membership_grade = ifelse(ent <= p | ent >= s, 0,
ifelse(ent >=q & ent <= r, 1,
ifelse(ent > p & ent < q,
(ent - p) / (q - p),
(s - ent) / (s - r))))
# passando os valores para o output
output = c(output, membership_grade)
}
#criando a possível nova linha do df res
new_row = data.frame('indices' = colnames(df)[c], 'p' = p, 'q' = q, 'r' = r,
's' = s, "coef.corr" = cor(df[,col_num], output))
# veridicando se a correlação existe e se a media da imagem é maior que o lim
if (!is.na(cor(df[,col_num], output)) &&
(1 - mean_lim_bottom) > mean(output) && mean(output) > mean_lim_bottom){
#verificando se o coeficiente encontrado e maior que o mínimo
if (sd(df[,col_num]) != 0 && sd(output) != 0 &&
cor(df[,col_num], output) > min(df_list[[c]][,"coef.corr"])){
#encontrando a linha  do valor minimo do coeficiente
j_min = match(min(df_list[[c]][,"coef.corr"]), df_list[[c]][,"coef.corr"])
#removendo a linha do valor mínimo
df_list[[c]] = df_list[[c]][-j_min,]
#adicionando o valor encontrado
df_list[[c]] = rbind(df_list[[c]], new_row)
# recolocando o valor do prob_runif para 0.1
prob_runif[c] = 0.1
print(paste(colnames(df)[c], 'p, q, r, s: ', p, q, r, s))
print(paste('media_coef: ', media_coef))
print(Sys.time())
print(paste("mean(output): ", mean(output)))
plot(input, output, xlab = colnames(df)[c])
plot(boa, xlab = colnames(df)[c])
}
else if (prob_runif[c] < 0.9){
prob_runif[c] = prob_runif[c]+(0.05/accurate)
}
}
}
media_all = c()
for (d in df_list) {
media_all = c(media_all, max(d[,'coef.corr']))
}
media_coef = mean(media_all)
}
}
if (round(mean(prob_runif),2) == 0.90){
break
}
}
return(df_list[1:length(df_list)])
}
look_fuzzy_set(crit_tri[[5]], colnames(crit_tri[[5]])[20], 5, 1, 0.1)
look_fuzzy_set(crit_tri[[5]], colnames(crit_tri[[5]])[20], 5, 1, 0.1)
look_fuzzy_set = function(df, col_obj, num_row, accurate, mean_lim_bottom) {
col_num = match(col_obj, colnames(df))
arredond = 2  # qtd de casa decimais para os parametros
# lista para conter as probabiblidades dos runifs
prob_runif = c()
# lista para conter os df com os valores dos paramentros
df_list = list()
for (c in 1:ncol(df)){
if (colnames(df)[c] != col_obj){
df_list[[c]] = data.frame(matrix(ncol = 6, nrow = 0))
colnames(df_list[[c]]) = c("indices", "p", "q", "r", "s", "coef.corr")
prob_runif = c(prob_runif, 0) # valor deve ser menor que 0.9
# por causa do break
}
}
repeat{
for (c in 1:(length(colnames(df))-1)) {
print(paste('indice: ', colnames(df)[c]))
if (colnames(df)[c] != col_obj){
input = df[,c]
#############       improve parameters search       ######################
##########################################################################
desv_times = 5  #multiplicador do desvio padrão, quanto maior, maior
#será a chance de encontrar outros valores fora da
#distribuição
if (nrow(df_list[[c]]) < num_row){
# Calculando os 5 percentis
percentis <- quantile(input, probs = seq(0, 1, 1/5)) # 1/5 é para
#encontrar 4 valores
# definindo os valores iniciais dos parametros
p = round(percentis[2], arredond)
q = round(percentis[3], arredond)
r = round(percentis[4], arredond)
s = round(percentis[5], arredond)
#gerando a função que mostra o grau de pertencimento ao conjunto de
#boas ações
boa = TrapezoidalFuzzyNumber(p, q, r, s)
output = c()
for (ent in input) {
# Cálculo do grau de pertinência
membership_grade = ifelse(ent <= p | ent >= s, 0,
ifelse(ent >=q & ent <= r, 1,
ifelse(ent > p & ent < q,
(ent - p) / (q - p),
(s - ent) / (s - r))))
# passando os valores para o output
output = c(output, membership_grade)
}
#criando a nova linha do df res
new_row = data.frame('indices' = colnames(df)[c], 'p' = p, 'q' = q, 'r' = r,
's' = s, "coef.corr" = cor(df[,col_num], output))
#adicionando o valor encontrado
df_list[[c]] = rbind(df_list[[c]], new_row)
#########       continues of improvement       #########################
########################################################################
} else {
choice_path = sample(c('rnorm', 'runif'), 1,
prob = c(1 - round(prob_runif[c],2),
round(prob_runif[c],2)))
#pesos para a média ponderada
pesos = abs(df_list[[c]][,'coef.corr']/sum(df_list[[c]][,'coef.corr']))
## selecionando aleatoriamente entre 'p' ou 's'
choice_param = sample(c('p', 's'), 1)
arredond = 2  # qtd de casa decimais para os parametros
p_col = df_list[[c]][,'p']
q_col = df_list[[c]][,'q']
r_col = df_list[[c]][,'r']
s_col = df_list[[c]][,'s']
#para evitar runifs com parametros menores ou maiores que o limite
# definindo os limites para os parametros
# from bottom to top
limit_max = sort(input)[length(input) - length(input)*mean_lim_bottom]
limit_min = sort(input)[(1-mean_lim_bottom)*length(input)]
#verificando qual coeficiente foi escolhido
if (choice_param == 'p'){
print('p first')
#se foi 'p' gerando os parametros do menor para o maior
#################     p       ##################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(p_col) == 0){
if (mean(p_col) == 0){
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
p = round(rnorm(1, sample(p_col, 1,prob = pesos),
sd = abs(mean(p_col))), arredond)
}
} else {
p = round(rnorm(1, mean = sample(p_col, 1, prob = pesos),
desv_times*sd(p_col)), arredond)
}
if (p < min(input)){
p = min(input)
} else if (p > max(input)){
p = max(input)
}
} else {
p = round(sample(sort(input)[1:match(limit_max,sort(input))], 1),
arredond)
}
#################     q     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(q_col) == 0){
if (mean(q_col) == 0){
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
abs(mean(q_col))), arredond)
}
} else {
q = round(rnorm(1, sample( q_col, 1, prob = pesos),
desv_times*sd(q_col)), arredond)
}
if (q < p){
q = p
} else if (q > max(input)){
q = max(input)
}
} else {
q = ifelse(p>=limit_max,p,
round(sample(sort(input)[match(p,sort(input)):length(input)], 1),
arredond))
}
#################     r     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(r_col) == 0){
if (mean(r_col) == 0){
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
abs(mean(r_col))), arredond)
}
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
desv_times*sd(r_col)), arredond)
}
if (r < q){
r = q
} else if (r > max(input)){
r = max(input)
}
} else {
print('r by sample')
r = round(sample(sort(input)[match(q,sort(input)):length(input)], 1),
arredond)
}
#################     s     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(s_col) == 0){
if (mean(s_col) == 0){
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
abs(mean(s_col))), arredond)
}
} else {
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
desv_times*sd(s_col)), arredond)
}
if (s < r){
s = r
} else if (s > max(input)){
s = max(input)
}
} else {
print('s by sample')
print(paste('r: ', r))
print(paste('match(r,sort(input)): ', match(r,sort(input))))
print(paste('sort(input)[match(r,sort(input)):length(input)]: ',
sort(input)[match(r,sort(input)):length(input)]))
print(paste('sample(sort(input)[match(r,sort(input)):length(input)], 1): ',
sample(sort(input)[match(r,sort(input)):length(input)], 1)))
s = round(sample(sort(input)[match(r,sort(input)):length(input)], 1),
arredond)
}
if (s < r){
s = r
}
} else {
print('s first')
#se foi o 's' gerando os parametros do maior para o menor
#################     s     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(s_col) == 0){
if (mean(s_col) == 0){
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
abs(mean(s_col))), arredond)
}
} else {
s = round(rnorm(1, sample(s_col, 1, prob = pesos),
desv_times*sd(s_col)), arredond)
}
if (s > max(input)){
s = max(input)
} else if (s < min(input)){
s = min(input)
}
} else {
s = round(sample(sort(input)[match(limit_min,sort(input)):length(input)], 1),
arredond)
}
#################     r     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(r_col) == 0){
if (mean(r_col) == 0){
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
abs(mean(r_col))), arredond)
}
} else {
r = round(rnorm(1, sample(r_col, 1, prob = pesos),
desv_times*sd(r_col)), arredond)
}
if (r > s){
r = s
} else if (r < min(input)){
r = min(input)
}
} else {
r = ifelse(s<=limit_min,s,round(sample(sort(input)[1:match(s,sort(input))],
1),arredond))
}
#################     q     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(q_col) == 0){
if (mean(q_col) == 0){
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
abs(mean(q_col))), arredond)
}
} else {
q = round(rnorm(1, sample(q_col, 1, prob = pesos),
desv_times*sd(q_col)), arredond)
}
if (q > r){
q = r
} else if (q < min(input)){
q = min(input)
}
} else {
q = round(sample(sort(input)[1:match(r,sort(input))], 1), arredond)
}
#################     p     ###################################
choice_path
#verificando a escolha do caminho, runif ou rnorm
if (choice_path == 'rnorm'){
#####   verificando se o desvio padrão é igual a zero
if (sd(p_col) == 0){
if (mean(p_col) == 0){
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
diff(range(input))), arredond)
} else {
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
sd = abs(mean(p_col))), arredond)
}
} else {
p = round(rnorm(1, sample(p_col, 1, prob = pesos),
desv_times*sd(p_col)), arredond)
}
if (p > q){
p = q
} else if (p < min(input)){
p = min(input)
}
} else {
p = round(sample(sort(input)[1:match(q, sort(input))], 1), arredond)
}
}
print(paste('p: ', p))
print(paste('q: ', q))
print(paste('r: ', r))
print(paste('s: ', s))
#gerando a função que mostra o grau de pertencimento ao conjunto de
#boas ações
boa = TrapezoidalFuzzyNumber(p, q, r, s)
output = c()
for (ent in input) {
# Cálculo do grau de pertinência
membership_grade = ifelse(ent <= p | ent >= s, 0,
ifelse(ent >=q & ent <= r, 1,
ifelse(ent > p & ent < q,
(ent - p) / (q - p),
(s - ent) / (s - r))))
# passando os valores para o output
output = c(output, membership_grade)
}
#criando a possível nova linha do df res
new_row = data.frame('indices' = colnames(df)[c], 'p' = p, 'q' = q, 'r' = r,
's' = s, "coef.corr" = cor(df[,col_num], output))
# veridicando se a correlação existe e se a media da imagem é maior que o lim
if (!is.na(cor(df[,col_num], output)) &&
(1 - mean_lim_bottom) > mean(output) && mean(output) > mean_lim_bottom){
#verificando se o coeficiente encontrado e maior que o mínimo
if (sd(df[,col_num]) != 0 && sd(output) != 0 &&
cor(df[,col_num], output) > min(df_list[[c]][,"coef.corr"])){
#encontrando a linha  do valor minimo do coeficiente
j_min = match(min(df_list[[c]][,"coef.corr"]), df_list[[c]][,"coef.corr"])
#removendo a linha do valor mínimo
df_list[[c]] = df_list[[c]][-j_min,]
#adicionando o valor encontrado
df_list[[c]] = rbind(df_list[[c]], new_row)
# recolocando o valor do prob_runif para 0.1
prob_runif[c] = 0.1
print(paste(colnames(df)[c], 'p, q, r, s: ', p, q, r, s))
print(paste('media_coef: ', media_coef))
print(Sys.time())
print(paste("mean(output): ", mean(output)))
plot(input, output, xlab = colnames(df)[c])
plot(boa, xlab = colnames(df)[c])
}
else if (prob_runif[c] < 0.9){
prob_runif[c] = prob_runif[c]+(0.05/accurate)
}
}
}
media_all = c()
for (d in df_list) {
media_all = c(media_all, max(d[,'coef.corr']))
}
media_coef = mean(media_all)
}
}
if (round(mean(prob_runif),2) == 0.90){
break
}
}
return(df_list[1:length(df_list)])
}
look_fuzzy_set(crit_tri[[5]], colnames(crit_tri[[5]])[20], 5, 1, 0.1)
